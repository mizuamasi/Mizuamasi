<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>フラグメントシェーダーエディタ</title>
    <style>
        body {
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #editor {
            width: 50%;
            height: 100%;
            box-sizing: border-box;
            padding: 10px;
            background-color: #2d2d2d;
            color: #ccc;
            position: relative;
        }
        #shaderCanvas {
            width: 50%;
            height: 100%;
            display: block;
        }
        #error {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            max-height: 100px;
            overflow-y: auto;
            background-color: #ffdddd;
            color: #a00;
            padding: 10px;
            box-sizing: border-box;
            display: none;
            font-family: monospace;
            white-space: pre-wrap;
        }
        .CodeMirror {
            height: 100%;
        }
        .error-line {
            background-color: rgba(255, 0, 0, 0.2);
        }
    </style>
    <!-- CodeMirrorのCSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/theme/dracula.min.css">
</head>
<body>
    <div id="editor">
        <textarea id="shaderCode">
void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord/iResolution.xy;

    // Time varying pixel color
    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));

    // Output to screen
    fragColor = vec4(col,1.0);
}
        </textarea>
        <div id="error"></div>
    </div>
    <canvas id="shaderCanvas"></canvas>

    <!-- CodeMirrorのJS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/clike/clike.min.js"></script>
    <script>
        // CodeMirrorの初期化
        const editor = CodeMirror.fromTextArea(document.getElementById('shaderCode'), {
            lineNumbers: true,
            mode: 'x-shader/x-fragment',
            theme: 'dracula',
            viewportMargin: Infinity
        });

        // エラー行を管理するための変数（行番号）
        let errorLineNumber = null;

        // WebGLコンテキストの取得
        const canvas = document.getElementById('shaderCanvas');
        const gl = canvas.getContext('webgl');
        if (!gl) {
            alert('WebGLがサポートされていません。');
        }

        // シェーダーのコンパイル
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                const info = gl.getShaderInfoLog(shader);
                gl.deleteShader(shader);
                throw new Error(info);
            }
            return shader;
        }

        // プログラムのリンク
        function createProgram(vertexSrc, fragmentSrc) {
            const vertexShader = compileShader(vertexSrc, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(fragmentSrc, gl.FRAGMENT_SHADER);
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                const info = gl.getProgramInfoLog(program);
                gl.deleteProgram(program);
                throw new Error(info);
            }
            return program;
        }

        // 初期の頂点シェーダー（全画面四角形用）
        const vertexShaderSrc = `
            attribute vec4 a_position;
            void main() {
                gl_Position = a_position;
            }
        `;

        let program;
        let startTime = Date.now();

        // プリペンドする行数（ユニフォームや関数定義など）
        const prependLines = `
precision mediump float;
uniform vec3 iResolution;
uniform float iTime;

`.split('\n').length;

        // シェーダーの更新と描画
        function updateShader() {
            const userCode = editor.getValue();
            const fragmentSrc = `
${prependLines > 0 ? 'precision mediump float;\nuniform vec3 iResolution;\nuniform float iTime;\n\n' : ''}
${userCode}

void main() {
    mainImage(gl_FragColor, gl_FragCoord.xy);
}
            `;
            try {
                if (program) {
                    gl.deleteProgram(program);
                }
                program = createProgram(vertexShaderSrc, fragmentSrc);
                gl.useProgram(program);

                // 四角形の頂点データ
                const vertices = new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                    -1,  1,
                     1, -1,
                     1,  1,
                ]);
                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

                const positionLoc = gl.getAttribLocation(program, 'a_position');
                gl.enableVertexAttribArray(positionLoc);
                gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

                // ユニフォームの設定
                const resolutionLoc = gl.getUniformLocation(program, 'iResolution');
                gl.uniform3f(resolutionLoc, canvas.width, canvas.height, 1.0);

                const timeLoc = gl.getUniformLocation(program, 'iTime');
                const currentTime = (Date.now() - startTime) / 1000.0;
                gl.uniform1f(timeLoc, currentTime);

                // エラーメッセージ非表示
                const errorDiv = document.getElementById('error');
                errorDiv.style.display = 'none';
                errorDiv.textContent = '';

                // エディタのエラーハイライトをクリア
                if (errorLineNumber !== null) {
                    editor.removeLineClass(errorLineNumber, 'background', 'error-line');
                    errorLineNumber = null;
                }
            } catch (e) {
                // エラーメッセージ表示と行番号の調整
                const errorDiv = document.getElementById('error');
                errorDiv.style.display = 'block';
                const errorMessages = parseShaderError(e.message);
                errorDiv.textContent = errorMessages.join('\n');

                // エディタ内のエラー行をハイライト
                const errorLines = extractErrorLines(errorMessages);
                if (errorLines.length > 0) {
                    const firstErrorLine = errorLines[0];
                    if (errorLineNumber !== null) {
                        editor.removeLineClass(errorLineNumber, 'background', 'error-line');
                    }
                    // エディタの行番号は0から始まるため、-1
                    const userErrorLine = firstErrorLine - 1;
                    if (userErrorLine >= 0) {
                        editor.addLineClass(userErrorLine, 'background', 'error-line');
                        errorLineNumber = userErrorLine;
                    }
                }
                return;
            }
            drawScene();
        }

        // シェーダーの描画
        function drawScene() {
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        // エラーメッセージを解析してユーザーのエディタ行番号に調整
        function parseShaderError(errorMessage) {
            const lines = errorMessage.split('\n');
            const adjustedErrors = [];
            lines.forEach(line => {
                const regex = /ERROR:\s*\d+:(\d+):\s*(.+)/;
                const match = line.match(regex);
                if (match) {
                    let lineNumber = parseInt(match[1]);
                    const message = match[2];
                    // 調整
                    const userLine = lineNumber - prependLines;
                    if (userLine > 0) {
                        adjustedErrors.push(`ERROR: ${userLine}: ${message}`);
                    } else {
                        // プリペンド行に関連するエラーの場合
                        adjustedErrors.push(`ERROR: [システム]: ${message}`);
                    }
                } else {
                    adjustedErrors.push(line);
                }
            });
            return adjustedErrors;
        }

        // エラーメッセージからエラー行番号を抽出
        function extractErrorLines(adjustedErrors) {
            const errorLines = [];
            adjustedErrors.forEach(line => {
                const regex = /ERROR:\s*(\d+):\s*/;
                const match = line.match(regex);
                if (match) {
                    const lineNumber = parseInt(match[1]);
                    if (lineNumber > 0) {
                        errorLines.push(lineNumber);
                    }
                }
            });
            return errorLines;
        }

        // リサイズ対応
        function resizeCanvas() {
            canvas.width = window.innerWidth / 2;
            canvas.height = window.innerHeight;
            if (gl && program) {
                updateShader();
            }
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // エディタの変更を監視して更新
        editor.on('change', () => {
            updateShader();
        });

        // 初回シェーダーのコンパイルと描画
        updateShader();

        // アニメーションループ
        function render() {
            if (program) {
                const timeLoc = gl.getUniformLocation(program, 'iTime');
                const currentTime = (Date.now() - startTime) / 1000.0;
                gl.uniform1f(timeLoc, currentTime);
                drawScene();
            }
            requestAnimationFrame(render);
        }
        render();
    </script>
</body>
</html>
